### 启动速度分类
- 冷启动：当启动应用时，后台没有该应用的(主UI)进程
- 热启动：当启动应用时，后台已有该应用的(主UI)进程

*xx的主UI进程是：com.xxx.mguard_cn*

### 量化
- 区分冷热启动
    + 根源在于是否要创建进程，即：ActivityThread.java中的performLaunchActivity时是否会创建Application对象并调用其onCreate方法 

- 量化启动耗时
    + 起点：
        - 一般以Application的attachBaseContext为起点
        - 但进程启动的原因：
            * 启动四大组件，不一定是Activity，而app的启动是最终看到UI界面
            * 如果调用进程中的service则也会启动进程，也会调用attachBaseContext，但不知道什么时候才会触发Activity的调用，所以评估有误差
        - 所以，以ActivityThread.java中的performLaunchActivity为起点来衡量比较好
    + 终点：
        - 一般是在Activity的onResume方法或者onDraw方法结束
        - 如果Activity中使用了ViewPager等，系统会对ViewPager中的视图异步绘制
        ```
        以下是ViewPager中放入三个Fragment的示例：
        02-14 11:38:54.572 7701-7701/com.example.jiao.mytest E/xxxxxx: MainActivity::onCreate
        02-14 11:38:54.609 7701-7701/com.example.jiao.mytest E/xxxxxx: MainActivity::onResume
        02-14 11:38:54.803 7701-7701/com.example.jiao.mytest E/xxxxxx: MyFragment::onCreateView MyFragment{3bc2422b #0 id=0x7f0c0051 android:switcher:2131492945:1}
        02-14 11:38:54.804 7701-7701/com.example.jiao.mytest E/xxxxxx: MyFragment::onActivityCreated MyFragment{3bc2422b #0 id=0x7f0c0051 android:switcher:2131492945:1}
        02-14 11:38:54.805 7701-7701/com.example.jiao.mytest E/xxxxxx: MyFragment::onCreateView MyFragment{3a217688 #1 id=0x7f0c0051 android:switcher:2131492945:0}
        02-14 11:38:54.806 7701-7701/com.example.jiao.mytest E/xxxxxx: MyFragment::onActivityCreated MyFragment{3a217688 #1 id=0x7f0c0051 android:switcher:2131492945:0}
        02-14 11:38:54.886 7701-7701/com.example.jiao.mytest E/xxxxxx: MyViewPager::onDraw
        02-14 11:38:54.940 7701-7701/com.example.jiao.mytest E/xxxxxx: MyViewPager::onDraw
        ```

### 方法
- UI加载延迟化
    + 如：xx有4~5个tab，可以先在ViewPager中加载第一个Fragment，一定时间后(如完成主页面动画后)，再加载其他tab的内容 (荣耀3c, 17s-->9s)
        - 如果一起放入ViewPager的adapter的话，会触发至少两个Fragment的初始化(如上日志所示) 
    + 进入app后的权限、功能引导弹窗等，可以放到一定时间后(如完成主页面动画后)
    + 主页面信息流：原来是在onCreate中获取数据并且加载好，待清理结束后，再将其展示出来；现在，待清理结束后，再获取信息流数据并且加载展示

- 耗时非UI操作异步化
    + 在MainActivity的onCreate获取信息流数据(创建PublicConditionNew耗时200ms)
    + 结果页广告数据的获取(NewMainFragment的onActivityCreated中的preloadAdData获取)
    + 插件化模块初始化BundleParser中的getAllBundleJson()(耗时700ms，因为恐惧没有及时深挖)

- 减少Activity跳转层级
    + splash页面本来是个activity，改成mainactivity的一个view(Activity启动耗时500ms)

- 布局优化

- 天花板：插件安装速度无法优化(5547ms)
    + 解决方案：
        - 更改产品策略，不要展示等待插件安装成功的SplashPluginLoadingActivity界面，直接进入“开始使用”按钮界面，然后再等待插件安装完成

### AOP
- 评估性能的时候要打很多日志，这就需要切面编程
- 框架：AspectJ