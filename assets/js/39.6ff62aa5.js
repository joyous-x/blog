(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{645:function(t,a,s){"use strict";s.r(a);var e=s(15),i=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"algorithm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#algorithm"}},[t._v("#")]),t._v(" Algorithm")]),t._v(" "),s("h2",{attrs:{id:"floyd算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#floyd算法"}},[t._v("#")]),t._v(" Floyd算法")]),t._v(" "),s("ul",[s("li",[t._v("Dis(AB) = min(Dis(AB), Dis(AK) + Dis(KB))")]),t._v(" "),s("li",[t._v("注意循环的嵌套顺序:\n"),s("ul",[s("li",[t._v("如果把检查所有节点K放在最内层(应该放在最外层)，那么结果将是不正确的")]),t._v(" "),s("li",[t._v("为什么呢？因为这样便过早的把A到B的最短路径确定下来了，而当后面存在更短的路径时，已经不再会更新了")])])])]),t._v(" "),s("h2",{attrs:{id:"dynamic-programming"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dynamic-programming"}},[t._v("#")]),t._v(" Dynamic Programming")]),t._v(" "),s("ul",[s("li",[t._v("使用条件："),s("strong",[t._v("无后效性")]),t._v(" "),s("ul",[s("li",[t._v('某阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响。简单的说，就是"未来与过去无关"，当前的状态是此前历史的一个完整总结，此前的历史只能通过当前状态去影响未来过程的演变。')])])]),t._v(" "),s("li",[t._v("常见问题\n"),s("ul",[s("li",[t._v("01背包问题、最长非降子序列")]),t._v(" "),s("li",[t._v("带权重的单源最短路")]),t._v(" "),s("li",[t._v("带权重、每步都有一定资源消耗(如:过路费)的单源最短路")])])])]),t._v(" "),s("h2",{attrs:{id:"α-β剪枝算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#α-β剪枝算法"}},[t._v("#")]),t._v(" α-β剪枝算法")]),t._v(" "),s("h2",{attrs:{id:"朴素贝叶斯"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#朴素贝叶斯"}},[t._v("#")]),t._v(" 朴素贝叶斯")]),t._v(" "),s("h2",{attrs:{id:"推荐算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#推荐算法"}},[t._v("#")]),t._v(" 推荐算法")]),t._v(" "),s("ul",[s("li",[t._v("协同过滤、LR、GBDT")])]),t._v(" "),s("h2",{attrs:{id:"树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#树"}},[t._v("#")]),t._v(" 树")]),t._v(" "),s("ul",[s("li",[t._v("二叉树、完全二叉树、平衡二叉树、二叉查找树（BST）\n"),s("ul",[s("li",[s("img",{attrs:{src:"rsc/algorithm.avl_rebalancing.png",alt:"二叉平衡树"}})])])]),t._v(" "),s("li",[t._v("红黑树")]),t._v(" "),s("li",[t._v("B，B+，B*树")]),t._v(" "),s("li",[t._v("LSM 树")]),t._v(" "),s("li",[t._v("最小生成树算法\n"),s("ul",[s("li",[t._v("https://blog.csdn.net/luoshixian099/article/details/51908175")])])])]),t._v(" "),s("p",[s("a",{attrs:{href:"#Algorithm"}},[s("em",[t._v("TOP")])])]),t._v(" "),s("h1",{attrs:{id:"cache"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cache"}},[t._v("#")]),t._v(" Cache")]),t._v(" "),s("h2",{attrs:{id:"lru-least-recently-used"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lru-least-recently-used"}},[t._v("#")]),t._v(" LRU (Least recently used)")]),t._v(" "),s("p",[t._v("其核心思想是:假设刚visit的item,很有可能在未来被revisit,丢弃最近最少访问的items")]),t._v(" "),s("ul",[s("li",[t._v("通常用双链表实现")]),t._v(" "),s("li",[t._v("缺点:忽略了frequency, 不适合大规模扫描等情况")]),t._v(" "),s("li",[t._v("LRU有一系列变种，比如LRU-N(如，LRU-2), 2Q, LIRS等。")])]),t._v(" "),s("h2",{attrs:{id:"lfu-least-frequently-used"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lfu-least-frequently-used"}},[t._v("#")]),t._v(" LFU (Least-frequently used)")]),t._v(" "),s("p",[t._v("其核心思想是:假设visit次数越多的item,很有可能在未来被revisit")]),t._v(" "),s("ul",[s("li",[t._v("适应大规模扫描")]),t._v(" "),s("li",[t._v("对热点友好")]),t._v(" "),s("li",[t._v("缺点:忽略了recency, 可能会积累不再使用的数据 tips: redis4.0开始支持了LFU,例如volatile-lfu, allkeys-lfu配置选项")])]),t._v(" "),s("h2",{attrs:{id:"arc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arc"}},[t._v("#")]),t._v(" ARC")]),t._v(" "),s("p",[t._v("ARC（Adaptive Replacement Cache）是一种适应性Cache算法, 它结合了LRU与LFU的特点。")]),t._v(" "),s("p",[t._v("ARC "),s("a",{attrs:{href:"https://dbs.uni-leipzig.de/file/ARC.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("论文"),s("OutboundLink")],1),t._v("，将整个Cache分成两部分，起始LRU和LFU各占一半，后续会动态适应调整partion的位置(记为p), 除此，LRU和LFU各自有一个ghost list(因此，一共4个list)。每次，被淘汰的item放到对应的ghost list中（ghost list只存key）, 例如：如果被evicted的item来自LRU的部分， 则该item对应的key会被放入LRU对应的ghost list")]),t._v(" "),s("ul",[s("li",[t._v("第一次cache miss, 则会放入LRU")]),t._v(" "),s("li",[t._v("如果cache hit, 如果LFU中没有，则放入LFU")]),t._v(" "),s("li",[t._v("如果cache miss, 但在ghost list中命中，这说明对应的cache如果再大一丁点儿就好了： 如果存在于LRU ghost list, 则p=p+1；否则存在于LFU ghost list, p=p-1.")]),t._v(" "),s("li",[t._v("也就是说，利用这种适应机制，当系统趋向于访问最近的内容，会更多地命中LRU ghost list，这样会增大LRU的空间； 当系统趋向于访问最频繁的内容，会更多地命中LFU ghost list，这样会增加LFU的空间.")])])])}),[],!1,null,null,null);a.default=i.exports}}]);