(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{558:function(e,t,l){"use strict";l.r(t);var a=l(15),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,l=e._self._c||t;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h1",{attrs:{id:"分布式一致性协议简介"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#分布式一致性协议简介"}},[e._v("#")]),e._v(" 分布式一致性协议简介")]),e._v(" "),l("h2",{attrs:{id:"raft"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#raft"}},[e._v("#")]),e._v(" Raft：")]),e._v(" "),l("ul",[l("li",[e._v("leader election\n"),l("ul",[l("li",[e._v("two timeouts\n"),l("ul",[l("li",[e._v("eletction timeout\n"),l("ul",[l("li",[e._v("randomized to be between 150ms and 300ms")])])]),e._v(" "),l("li",[e._v("heartbeat timeout:\n"),l("ul",[l("li",[e._v("usage: Append Entries messages")])])])])])])]),e._v(" "),l("li",[e._v("log replication\n"),l("ul",[l("li",[e._v("client make request to leader")]),e._v(" "),l("li",[e._v("leader make log entry and log replication, expecting major votes from all clients")]),e._v(" "),l("li",[e._v("leader respone to client and accept client's request")]),e._v(" "),l("li",[e._v("leader make log replication that commit client's request")])])]),e._v(" "),l("li",[e._v("status\n"),l("ul",[l("li",[e._v("follower ---\x3e candidate ---\x3e leader\n"),l("ul",[l("li",[e._v("follower become candidate when eletction timeout")]),e._v(" "),l("li",[e._v("candidate become leader when major votes")])])])])]),e._v(" "),l("li",[e._v("infomations:\n"),l("ul",[l("li",[e._v("url\t: http://thesecretlivesofdata.com/raft/")]),e._v(" "),l("li",[e._v("github: https://github.com/benbjohnson/thesecretlivesofdata")])])])]),e._v(" "),l("h2",{attrs:{id:"paxos"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#paxos"}},[e._v("#")]),e._v(" Paxos：")]),e._v(" "),l("h4",{attrs:{id:"basic-paxos"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#basic-paxos"}},[e._v("#")]),e._v(" Basic Paxos：")]),e._v(" "),l("ul",[l("li",[e._v("abstract\n"),l("ul",[l("li",[e._v("强一致性")]),e._v(" "),l("li",[e._v("Proposer、Acceptor、ProposalID(以高位时间戳 + 低位机器 IP 可以保证唯一性和递增性)")])])]),e._v(" "),l("li",[e._v("steps:\n"),l("ul",[l("li",[l("p",[e._v("prepare")]),e._v(" "),l("ul",[l("li",[e._v("Proposer 发送 Prepare\n"),l("ul",[l("li",[e._v("生成新的ProposalID")])])]),e._v(" "),l("li",[e._v("Acceptor 应答 Prepare\n"),l("ul",[l("li",[e._v("response：\n"),l("ul",[l("li",[e._v("返回自己已经 Accept 过的提案中 ProposalID 最大的那个提案的内容，如果没有则返回空值;")]),e._v(" "),l("li",[e._v("应答前要在本地持久化当前 Propsalid")])])]),e._v(" "),l("li",[e._v("promise：\n"),l("ul",[l("li",[e._v("不再应答 Proposalid 小于等于（注意：这里是 <= ）当前请求的 PrepareRequest")]),e._v(" "),l("li",[e._v("不再应答 Proposalid 小于（注意：这里是 < ）当前请求的 AcceptRequest")])])])])])])]),e._v(" "),l("li",[l("p",[e._v("accept")]),e._v(" "),l("ul",[l("li",[e._v("Proposer 发送 Accept\n"),l("ul",[l("li",[e._v("“提案生成规则”：\n"),l("ul",[l("li",[e._v("Proposer 收集到多数派应答的 PrepareResponse 后，从中选择proposalid最大的提案内容，作为要发起 Accept 的提案，如果这个提案为空值，则可以自己随意决定提案内容。然后携带上当前 Proposalid，向 Paxos 集群的所有机器发送 AccpetRequest。")])])])])]),e._v(" "),l("li",[e._v("Acceptor 应答 Accept\n"),l("ul",[l("li",[e._v("检查AccpetRequest不违背自己之前作出的“两个承诺”情况下，持久化当前 Proposalid 和提案内容。最后 Proposer 收集到多数派应答的 AcceptResponse 后，形成决议。")])])])])])])]),e._v(" "),l("li",[e._v("infomations\n"),l("ul",[l("li",[e._v("http://chuansong.me/n/2189245")]),e._v(" "),l("li",[e._v("https://blog.csdn.net/heiyeshuwu/article/details/42426811")])])])]),e._v(" "),l("h4",{attrs:{id:"fast-paxos"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#fast-paxos"}},[e._v("#")]),e._v(" Fast Paxos")]),e._v(" "),l("h4",{attrs:{id:"multi-paxos"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#multi-paxos"}},[e._v("#")]),e._v(" Multi Paxos")]),e._v(" "),l("h2",{attrs:{id:"gossip"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#gossip"}},[e._v("#")]),e._v(" Gossip:")]),e._v(" "),l("ul",[l("li",[e._v("abstract\n"),l("ul",[l("li",[e._v("反熵（Anti-Entropy）")]),e._v(" "),l("li",[e._v("种子节点")]),e._v(" "),l("li",[e._v("去中心化")]),e._v(" "),l("li",[e._v("最终一致性（现实中存在，理论无法证明的时间点）")])])]),e._v(" "),l("li",[e._v("weakness\n"),l("ul",[l("li",[e._v("冗余通信")])])]),e._v(" "),l("li",[e._v("kernel\n"),l("ul",[l("li",[e._v("信息同步")]),e._v(" "),l("li",[e._v("Merkle tree(MT)是一个非常适合同步的数据结构")])])]),e._v(" "),l("li",[e._v("paper\n"),l("ul",[l("li",[e._v("Efficient Reconciliation and Flow Control for Anti-Entropy Protocols")])])])]),e._v(" "),l("h2",{attrs:{id:"totem"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#totem"}},[e._v("#")]),e._v(" Totem：")]),e._v(" "),l("ul",[l("li",[e._v("abstract\n"),l("ul",[l("li",[e._v("强一致性")])])]),e._v(" "),l("li",[e._v("steps：\n"),l("ul",[l("li",[e._v("通信方式\n"),l("ul",[l("li",[e._v("当集群有节点要发起通信时，需要等待token。当拿到token后，先广播这次需要发送的数据，然后传递token来确认所有人都接收到消息。\n如果确认成功，释放token")])])]),e._v(" "),l("li",[e._v("节点的加入和退出\n"),l("ol",[l("li",[e._v("当集群中有节点加入时，加入的节点广播一个加入信息，所有人都开始广播自己的信息，当所有人都获得同伴信息，开始由id最小的人提交一个token，交由所有节点确认。")]),e._v(" "),l("li",[e._v("如果都确认后，则节点正式加入，开始正常运行。")]),e._v(" "),l("li",[e._v("当集群有节点退出时，由于令牌环断链，触发token超时，则同样开始广播信息，然后由最小id提交token，经过确认后恢复正常。")])])])])])])])}),[],!1,null,null,null);t.default=i.exports}}]);