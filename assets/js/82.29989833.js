(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{555:function(v,_,l){"use strict";l.r(_);var i=l(14),e=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"代码重构培训-笔记"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#代码重构培训-笔记"}},[v._v("#")]),v._v(" 代码重构培训(笔记)")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("持续集成：保证日常流程中所有开发人员的code clean")])]),v._v(" "),l("li",[l("p",[v._v("对于眼中的烂项目，如果用同样的思路去重构，只不过是一个新的烂项目的开始")])]),v._v(" "),l("li",[l("p",[v._v("生成烂代码的原因，一般人都会认为有以下几种甚至更过：")]),v._v(" "),l("ul",[l("li",[v._v("需求变更")]),v._v(" "),l("li",[v._v("旧的逻辑难以维护")]),v._v(" "),l("li",[v._v("交付压力")]),v._v(" "),l("li",[v._v("自己的代码设计(这个是关键)")])])]),v._v(" "),l("li",[l("p",[v._v("烂代码产生的一个重要原因是：")]),v._v(" "),l("ul",[l("li",[v._v("破窗效应 ---\x3e 惯性 ---\x3e 好的更好，坏的更坏")])])]),v._v(" "),l("li",[l("p",[v._v("死循环：无单元测试 ---\x3e 不敢动以前代码 ---\x3e 烂代码")]),v._v(" "),l("ul",[l("li",[v._v("单元测试：保证功能细节正确")]),v._v(" "),l("li",[v._v("测试人员：集成测试，保证产品功能正常")])])]),v._v(" "),l("li",[l("p",[v._v("重构 不等于 重写")]),v._v(" "),l("ul",[l("li",[v._v("重构是，小步迭代，逐步验证。重写是，完全推翻重来。")])])]),v._v(" "),l("li",[l("p",[v._v("重构的重要原则：")]),v._v(" "),l("ul",[l("li",[v._v("重构是在不改变原有代码行为的前提下，对其进行的一系列小步骤的改进。")]),v._v(" "),l("li",[v._v("重构是baby step，也就是小步测试，逐步完成。")])])]),v._v(" "),l("li",[l("p",[v._v("first， do no harm。重构过程，首先要做到不伤害。")])]),v._v(" "),l("li",[l("p",[v._v("重构时：")]),v._v(" "),l("ul",[l("li",[v._v("重要的就是要解耦（函数内、函数间等），否则很难重构。")]),v._v(" "),l("li",[v._v("重构时，勿以善小而不为，勿以恶小而为之")])])]),v._v(" "),l("li",[l("p",[v._v("重构中，要充分使用工具：")]),v._v(" "),l("ul",[l("li",[v._v("编程工具中 refactor 功能的使用")]),v._v(" "),l("li",[v._v("svn status")]),v._v(" "),l("li",[v._v("持续集成，code review（代码质量的可视化）")])])]),v._v(" "),l("li",[l("p",[v._v("在原有代码基础上改动时，代码质量保证方法：")]),v._v(" "),l("ul",[l("li",[v._v("不伤害\n"),l("ul",[l("li",[v._v("隔离原有代码，尽量不该动原有逻辑，先保证原有代码不动，再增加新功能")]),v._v(" "),l("li",[v._v("优先重构痛点：经常改动的复杂代码")])])]),v._v(" "),l("li",[v._v("逐步验证\n"),l("ul",[l("li",[v._v("单元测试")])])]),v._v(" "),l("li",[v._v("过渡设计")])])]),v._v(" "),l("li",[l("p",[v._v("代码是债务：")]),v._v(" "),l("ul",[l("li",[v._v("代码clean，需要从刻意到随意")])])]),v._v(" "),l("li",[l("p",[v._v("把数据处理封装，避免需要修改时，到处找数据的使用点进行修改，而造成 漏掉 或者 修改点过多造成工作量过大的问题。")])]),v._v(" "),l("li",[l("p",[v._v("public函数是流程函数，只应由各种独立功能的函数组成")])]),v._v(" "),l("li",[l("p",[v._v("修改代码时，如果没有做到新旧代码隔离，代码会逐步变成各种补丁交叉，造成可读性、可维护性急剧下降")])]),v._v(" "),l("li",[l("p",[v._v("写新代码时要做到：")]),v._v(" "),l("ul",[l("li",[v._v("小步重构\n"),l("ul",[l("li",[v._v("一定要用单元测试保证")]),v._v(" "),l("li",[v._v("制定代码底限或者重构底限，依照规则review代码（用规则发现代码中坏味道）")])])]),v._v(" "),l("li",[v._v("code review\n"),l("ul",[l("li",[v._v("保证 code clean，延长代码的生命周期")])])])])]),v._v(" "),l("li",[l("p",[v._v("代码隔离的四大类方法：")]),v._v(" "),l("ul",[l("li",[v._v("新生方法 sprout method")]),v._v(" "),l("li",[v._v("新生类 sprout class\n"),l("ul",[l("li",[v._v("接口、观察者、直接加功能类")])])]),v._v(" "),l("li",[v._v("外覆方法 wrapper method")]),v._v(" "),l("li",[v._v("外覆类 wrapper class\n"),l("ul",[l("li",[v._v("代理、装饰、aop方式")])])])])]),v._v(" "),l("li",[l("p",[v._v("单一原则")]),v._v(" "),l("ul",[l("li",[v._v("单一抽象原则（SLAP），单一代码层次抽象")]),v._v(" "),l("li",[v._v("单一原则，查询、执行分离")])])])]),v._v(" "),l("blockquote",[l("p",[v._v("重构相关书籍：\n《重构-改善既有代码的设计》\n《程序员的职业素养》\n《修改代码的艺术》")])])])}),[],!1,null,null,null);_.default=e.exports}}]);