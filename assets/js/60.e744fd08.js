(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{584:function(v,_,t){"use strict";t.r(_);var l=t(15),r=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"tcp与udp-对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp与udp-对比"}},[v._v("#")]),v._v(" TCP与UDP 对比")]),v._v(" "),t("hr"),v._v(" "),t("p",[t("strong",[v._v("面向报文的传输方式")]),v._v("是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。")]),v._v(" "),t("p",[t("strong",[v._v("面向字节流")]),v._v("的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。")]),v._v(" "),t("h2",{attrs:{id:"tcp协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp协议"}},[v._v("#")]),v._v(" TCP协议")]),v._v(" "),t("ul",[t("li",[v._v("Transmission Control Protocol，传输控制协议")]),v._v(" "),t("li",[v._v("面向连接的协议")]),v._v(" "),t("li",[v._v("需要三次握手建立连接")]),v._v(" "),t("li",[v._v("需要四次挥手断开连接")]),v._v(" "),t("li",[v._v("TCP报头最小长度：20字节")])]),v._v(" "),t("h2",{attrs:{id:"三次握手的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手的过程"}},[v._v("#")]),v._v(" 三次握手的过程：")]),v._v(" "),t("ol",[t("li",[v._v("客户端发送：SYN = 1, SEQ = X, 端口号")]),v._v(" "),t("li",[v._v("服务器回复：SYN = 1, ACK = X + 1, SEQ = Y")]),v._v(" "),t("li",[v._v("客户端发送：ACK = Y + 1, SEQ = X + 1")])]),v._v(" "),t("blockquote",[t("p",[v._v("确认应答信号ACK = 收到的SEQ + 1。\n连接建立中，同步信号SYN始终为1。连接建立后，同步信号SYN=0。")])]),v._v(" "),t("h2",{attrs:{id:"四次挥手过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手过程"}},[v._v("#")]),v._v(" 四次挥手过程")]),v._v(" "),t("ol",[t("li",[v._v("A向B提出停止连接请求，FIN = 1")]),v._v(" "),t("li",[v._v("B收到，ACK = 1")]),v._v(" "),t("li",[v._v("B向A提出停止连接请求，FIN = 1")]),v._v(" "),t("li",[v._v("A收到，ACK = 1")])]),v._v(" "),t("p",[t("strong",[v._v("优点：")])]),v._v(" "),t("ul",[t("li",[v._v("可靠，稳定\n"),t("ul",[t("li",[v._v("传递数据前，会有三次握手建立连接")]),v._v(" "),t("li",[v._v("传递数据时，有确认、窗口、重传、拥塞控制")]),v._v(" "),t("li",[v._v("传递数据后，会断开连接节省系统资源")])])])]),v._v(" "),t("p",[t("strong",[v._v("缺点：")])]),v._v(" "),t("ul",[t("li",[v._v("传输慢，效率低，占用系统资源高\n"),t("ul",[t("li",[v._v("传递数据前，建立连接需要耗时")]),v._v(" "),t("li",[v._v("传递数据时，确认、重传、拥塞等会消耗大量时间以及CPU和内存等硬件资源")])])]),v._v(" "),t("li",[v._v("易被攻击\n"),t("ul",[t("li",[v._v("因为有确认机制，三次握手等机制，容易被人利用，实现DOS 、DDOS攻击")])])])]),v._v(" "),t("p",[t("strong",[v._v("如何保证接收的顺序性：")])]),v._v(" "),t("ul",[t("li",[v._v("TCP协议使用SEQ和ACK机制保证了顺序性")]),v._v(" "),t("li",[v._v("TCP的每个报文都是有序号的。确认应答信号ACK=收到的SEQ+1")])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"udp协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp协议"}},[v._v("#")]),v._v(" UDP协议")]),v._v(" "),t("ul",[t("li",[v._v("User Data Protocol，用户数据包协议")]),v._v(" "),t("li",[v._v("面向无连接的协议")]),v._v(" "),t("li",[v._v("UDP报头只有8字节")])]),v._v(" "),t("p",[t("strong",[v._v("简介：")])]),v._v(" "),t("ul",[t("li",[v._v("传输数据之前源端和终端不建立连接")]),v._v(" "),t("li",[v._v("在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制")]),v._v(" "),t("li",[v._v("在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段")]),v._v(" "),t("li",[v._v("由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息")]),v._v(" "),t("li",[v._v("UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小")]),v._v(" "),t("li",[v._v("吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制")]),v._v(" "),t("li",[v._v("UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表。")]),v._v(" "),t("li",[v._v("UDP是面向报文的。")])]),v._v(" "),t("blockquote",[t("p",[v._v("使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。")])]),v._v(" "),t("p",[t("strong",[v._v("优点：")])]),v._v(" "),t("ul",[t("li",[v._v("传输速率快\n"),t("ul",[t("li",[v._v("传输数据前，不需要像TCP一样建立连接")]),v._v(" "),t("li",[v._v("传输数据时，没有确认、窗口、重传、拥塞控制等机制")])])]),v._v(" "),t("li",[v._v("较安全\n"),t("ul",[t("li",[v._v("由于没有了TCP的一些机制，被攻击者利用的漏洞就少了")])])])]),v._v(" "),t("p",[t("strong",[v._v("缺点：")])]),v._v(" "),t("ul",[t("li",[v._v("不可靠，不稳定\n"),t("ul",[t("li",[v._v("由于没有了TCP的机制，在数据传输时如果网络不好，很可能丢包")])])])]),v._v(" "),t("p",[t("strong",[v._v("用UDP协议通讯时怎样得知目标机是否获得了数据包")]),v._v("\n仿造TCP的做法，每发一个UDP包，都在里面加一个SEQ序号，接收方收到包后，将SEQ序号回复给发送方。如果发送方在指定时间以内没有收到回应，说明丢包了。")]),v._v(" "),t("h2",{attrs:{id:"tcp与udp的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp与udp的区别"}},[v._v("#")]),v._v(" TCP与UDP的区别")]),v._v(" "),t("hr"),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("TCP")]),v._v(" "),t("th",[v._v("UDP")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("TCP面向有链接的通信服务")]),v._v(" "),t("td",[v._v("TCP面向无链接的通信服务")])]),v._v(" "),t("tr",[t("td",[v._v("TCP提供可靠的通信传输")]),v._v(" "),t("td",[v._v("UDP不可靠,会丢包")])]),v._v(" "),t("tr",[t("td",[v._v("TCP保证数据顺序")]),v._v(" "),t("td",[v._v("UDP不保证")])]),v._v(" "),t("tr",[t("td",[v._v("TCP数据无边界")]),v._v(" "),t("td",[v._v("UDP有边界")])]),v._v(" "),t("tr",[t("td",[v._v("TCP速度慢")]),v._v(" "),t("td",[v._v("UDP速度快")])]),v._v(" "),t("tr",[t("td",[v._v("TCP面向字节流")]),v._v(" "),t("td",[v._v("UDP面向报文")])]),v._v(" "),t("tr",[t("td",[v._v("TCP一对一")]),v._v(" "),t("td",[v._v("UDP可以一对一，一对多")])]),v._v(" "),t("tr",[t("td",[v._v("TCP报头至少20字节")]),v._v(" "),t("td",[v._v("UDP报头8字节")])]),v._v(" "),t("tr",[t("td",[v._v("TCP有流量控制，拥塞控制")]),v._v(" "),t("td",[v._v("UDP没有")])])])]),v._v(" "),t("h2",{attrs:{id:"为什么udp比tcp快"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么udp比tcp快"}},[v._v("#")]),v._v(" "),t("strong",[v._v("为什么UDP比TCP快")])]),v._v(" "),t("ol",[t("li",[v._v("TCP需要三次握手")]),v._v(" "),t("li",[v._v("TCP有拥塞控制，控制流量等机制")])]),v._v(" "),t("h2",{attrs:{id:"为什么tcp比udp可靠"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么tcp比udp可靠"}},[v._v("#")]),v._v(" "),t("strong",[v._v("为什么TCP比UDP可靠")])]),v._v(" "),t("ol",[t("li",[v._v("TCP是面向有连接的，建立连接之后才发送数据；而UDP则不管对方存不存在都会发送数据。")]),v._v(" "),t("li",[v._v("TCP有确认机制，接收端每收到一个正确包都会回应给发送端。超时或者数据包不完整的话发送端会重传。UDP没有。因此可能丢包。")])]),v._v(" "),t("h2",{attrs:{id:"什么时候使用tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么时候使用tcp"}},[v._v("#")]),v._v(" "),t("strong",[v._v("什么时候使用TCP")])]),v._v(" "),t("p",[v._v("当对网络通讯质量有要求的时候：")]),v._v(" "),t("ul",[t("li",[v._v("比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，")]),v._v(" "),t("li",[v._v("比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。")])]),v._v(" "),t("p",[v._v("在日常生活中，常见使用TCP协议的应用如下：")]),v._v(" "),t("ul",[t("li",[v._v("浏览器，用的HTTP")]),v._v(" "),t("li",[v._v("FlashFXP，用的FTP")]),v._v(" "),t("li",[v._v("Outlook，用的POP、SMTP")]),v._v(" "),t("li",[v._v("QQ文件传输")])]),v._v(" "),t("p",[t("strong",[v._v("什么时候应该使用UDP：")])]),v._v(" "),t("ul",[t("li",[v._v("当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。")]),v._v(" "),t("li",[v._v("比如，日常生活中，常见使用UDP协议的应用如下：\n"),t("ul",[t("li",[v._v("QQ语音")]),v._v(" "),t("li",[v._v("QQ视频")]),v._v(" "),t("li",[v._v("TFTP")])])])]),v._v(" "),t("h2",{attrs:{id:"tcp无边界-udp有边界"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp无边界-udp有边界"}},[v._v("#")]),v._v(" "),t("strong",[v._v("TCP无边界，UDP有边界")])]),v._v(" "),t("p",[t("strong",[v._v("TCP无边界")])]),v._v(" "),t("ul",[t("li",[v._v("客户端分多次发送数据给服务器，若服务器的缓冲区够大，那么服务器端会在客户端发送完之后一次性接收过来，所以是无边界的；")])]),v._v(" "),t("p",[t("strong",[v._v("UDP有边界")])]),v._v(" "),t("ul",[t("li",[v._v("客户端每发送一次，服务器端就会接收一次，也就是说发送多少次就会接收多少次，因此是有边界的。")])])])}),[],!1,null,null,null);_.default=r.exports}}]);