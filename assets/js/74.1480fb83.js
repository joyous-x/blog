(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{703:function(t,e,v){"use strict";v.r(e);var i=v(16),_=Object(i.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"qt-基础汇总"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#qt-基础汇总"}},[t._v("#")]),t._v(" Qt 基础汇总")]),t._v(" "),v("h2",{attrs:{id:"一、style"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、style"}},[t._v("#")]),t._v(" 一、Style")]),t._v(" "),v("p",[t._v("如果一个 widget 没有被嵌入到另外一个 widget 中，那么这个 widget 就叫做 window，即一个独立的窗口。")]),t._v(" "),v("p",[t._v("一个 widget 的构造函数可以接受一个或者两个标准参数:")]),t._v(" "),v("ol",[v("li",[t._v("QWidget *parent = 0\n"),v("ul",[v("li",[t._v("如果 parent 为 0（默认值），那么这个新widget就会变成一个独立的window。")]),t._v(" "),v("li",[t._v("如果 parent 不为0，那么新创建的 widget 是 parent 的一个子窗口，但是此时我们新创建的widget的形状会受其父窗口形状的约束。（除非你指定这个新创建的widget的window flag为Qt::Window）")])])]),t._v(" "),v("li",[t._v("Qt::WindowFlags f = 0\n"),v("ul",[v("li",[t._v("这个参数用来设置新创建的 widget 的 window flags(例如是否有最大化按钮等)。")]),t._v(" "),v("li",[t._v("默认的参数几乎对所有的widget都是适用的。但如果你需要一个没有边框的widget，那么需要使用特定的flag(如，Qt::FramelessWindowHint)。")])])])]),t._v(" "),v("p",[t._v("此外，widget 可以通过 setAttribute() 函数设置属性，如，setAttribute(Qt::WA_StyledBackground) 不使用从父对象继承来的 QSS 样式(如，背景、边框、字体等)。")]),t._v(" "),v("h2",{attrs:{id:"二、layout-management"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、layout-management"}},[t._v("#")]),t._v(" 二、Layout Management")]),t._v(" "),v("ul",[v("li",[t._v("Layout Management\n"),v("ul",[v("li",[t._v("size policy使得layout management system（布局管理系统）拥有良好的默认大小变化管理依据")]),t._v(" "),v("li",[t._v("默认的size policy表示widget的大小可以自由变化，一般倾向于采用sizeHint()返回的大小，这对大多数的widget来说已经足够好了。")]),t._v(" "),v("li",[t._v("提示：顶层widget的大小一般约束为桌面大小长度和宽度的的2/3，但我们也可以通过resize()函数来手动改变大小。")])])])]),t._v(" "),v("h2",{attrs:{id:"三、size"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、size"}},[t._v("#")]),t._v(" 三、Size")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("类别")]),t._v(" "),v("th",[t._v("函数名")]),t._v(" "),v("th",[t._v("效果")]),t._v(" "),v("th",[t._v("作用")]),t._v(" "),v("th",[t._v("注意事项")])])]),t._v(" "),v("tbody",[v("tr",[v("td"),t._v(" "),v("td",[v("code",[t._v("setMinimumSize(w,h)")]),v("br"),v("code",[t._v("setMaximumSize(w,h)")])]),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td",[t._v("优先级最高")])]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td",[v("code",[t._v("setFixedSize(x, y, w, h)")])]),t._v(" "),v("td",[t._v("其实就是同时："),v("code",[t._v("setMinimumSize(w,h); setMaximumSize(w,h);")])]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("setFixedSize 后再调整窗口大小无效，不过，可以如下设置使其生效："),v("br"),v("code",[t._v("setMinimumSize(0,0); setMaximumSize(QSize(QWIDGETSIZE_MAX,QWIDGETSIZE_MAX)")])])]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td",[v("code",[t._v("resize(x, y, w, h)")])]),t._v(" "),v("td",[t._v("调整的大小受 minimumSize() 和 maximumSize() 约束")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("在"),v("em",[t._v("窗口")]),t._v(" resize 时如果 w 或者 h 的值小于窗口内某个控件的 w或h，那么 resize 就在这个方向上无效，此时Qt会自动生成一个合适的值")])]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td",[v("code",[t._v("setGeometry(x, y, w, h)")])]),t._v(" "),v("td",[t._v("其实就是 "),v("code",[t._v("resize")]),t._v("和 "),v("code",[t._v("move")]),t._v(" 的组合"),v("br"),v("br"),t._v("调整的大小受 minimumSize() 和 maximumSize() 约束")]),t._v(" "),v("td",[t._v("控制 widget 相对于其父窗口的几何结构(不包括窗口边框，注意和frameGeometry区别)")]),t._v(" "),v("td",[t._v("1.setGeometry 时，如果控件可见(visible), 会即时接收到 moveEvent() 和 resizeEvent()。如果控件当前不可见, 会保证在控件被显示前接收到相关事件。"),v("br"),t._v("2. Warning: Calling setGeometry() inside resizeEvent() or moveEvent() can lead to infinite recursion.")])]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td",[v("code",[t._v("adjustSize()")])]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("Adjusts the size of the widget to fit its contents")]),t._v(" "),v("td",[t._v("当 sizeHint() 有效(如，size hint 的 w 和 h 都 >= 0)时，会采用它的值；不然的话，会设置它的size 为覆盖所有子控件的矩形区域")])]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td",[v("code",[t._v("pos()")])]),t._v(" "),v("td",[t._v("widget相对于其父widget的位置")]),t._v(" "),v("td"),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td",[v("code",[t._v("rect()")])]),t._v(" "),v("td",[t._v("widget除去窗口边框的内在几何矩形")]),t._v(" "),v("td"),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td",[v("code",[t._v("size()")])]),t._v(" "),v("td",[t._v("widget除去边框之外的大小")]),t._v(" "),v("td"),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td",[v("code",[t._v("sizeHint()")])]),t._v(" "),v("td",[t._v("This property holds the recommended size for the widget.")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("如果此小部件没有 layout 时，则 sizeHint() 的默认实现返回一个无效值，否则返回 layout 的首选大小(preferred size)。")])])])]),t._v(" "),v("p",[t._v("另外，如果控件被放进 layout 里以后，大小由 layout 控制，resize 就不起作用了。不过：")]),t._v(" "),v("ul",[v("li",[t._v("可以通过 setMinimumSize 和 setMaximumSize 控制大小")]),t._v(" "),v("li",[t._v("可以通过 move 移动位置")])]),t._v(" "),v("h3",{attrs:{id:"思考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#思考"}},[t._v("#")]),t._v(" 思考")]),t._v(" "),v("ol",[v("li",[t._v("如下设置 qss 的话，新建名为 SpecialButton 的 MyPushButton 控件，会出现 minimumHeight() > maximumHeight() 的情形，此时，设置 setFixedSize 会生效吗？")])]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("/* 按钮 */\nMyPushButton {\n    min-height:50px;\n    max-height:50px;\n}\n\n/* 按钮: 名为 SpecialButton */\nMyPushButton#SpecialButton {\n  min-width:  50px;\n  min-height: 100px;\n}\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br"),v("span",{staticClass:"line-number"},[t._v("10")]),v("br"),v("span",{staticClass:"line-number"},[t._v("11")]),v("br")])]),v("h2",{attrs:{id:"四、event"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、event"}},[t._v("#")]),t._v(" 四、Event")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("类别")]),t._v(" "),v("th",[t._v("方法")]),t._v(" "),v("th",[t._v("说明")]),t._v(" "),v("th",[t._v("注意事项")])])]),t._v(" "),v("tbody",[v("tr",[v("td"),t._v(" "),v("td",[v("code",[t._v("mouseReleaseEvent()")])]),t._v(" "),v("td",[t._v("收到鼠标按下事件的 widget，也将接收鼠标释放事件")]),t._v(" "),v("td",[t._v("如果用户在某 widget 上按下鼠标，然后松开鼠标前拖动鼠标到别的地方，那么此 widget 也将接收到释放事件。"),v("br"),t._v("有一个例外：如果在按住鼠标按钮的同时出现弹出菜单，则该弹出窗口会立即窃取鼠标事件。")])]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td",[v("code",[t._v("enterEvent()")])]),t._v(" "),v("td",[t._v("鼠标进入该 widget 所在屏幕区域时被调用")]),t._v(" "),v("td",[t._v("该 widget 的屏幕区域不包括其子 widget 的屏幕区域")])]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td",[v("code",[t._v("leaveEvent()")])]),t._v(" "),v("td",[t._v("鼠标离开widget所在屏幕区域时被调用，但是如果鼠标进入了子widget屏幕区域时该函数不会被调用")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td",[v("code",[t._v("moveEvent()")])]),t._v(" "),v("td",[t._v("widget 相对于其父 widget 被移动时被调用")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td",[v("code",[t._v("closeEvent()")])]),t._v(" "),v("td",[t._v("用户关闭 widget 时或者调用 close() 函数时被调用")]),t._v(" "),v("td")])])]),t._v(" "),v("h2",{attrs:{id:"五、reference"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五、reference"}},[t._v("#")]),t._v(" 五、Reference")]),t._v(" "),v("ul",[v("li",[t._v("https://blog.csdn.net/dengjin20104042056/article/details/115304706")]),t._v(" "),v("li",[v("a",{attrs:{href:"https://doc.qt.io/qt-5/layout.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Layout Management"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://doc.qt.io/qt-5.15/eventsandfilters.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("The Event System"),v("OutboundLink")],1)])]),t._v(" "),v("p",[t._v("所有定义了 signal 和 slot 的类，在类定义的开始处的 Q_OBJECT 宏都是必需的。")]),t._v(" "),v("p",[t._v("QDialog : show() 和 exec() : 非模态 和 模态")]),t._v(" "),v("p",[t._v("Qt 窗口")]),t._v(" "),v("ul",[v("li",[t._v("Qt 会对所有的窗口进行跟踪，所以，new 一个 window 后，可以没有主动 delete")]),t._v(" "),v("li",[t._v("用户关闭一个主窗口时，默认行为是隐藏它，可以通过 Qt::WA_DeleteOnClose 属性进行修改")])]),t._v(" "),v("p",[t._v("QSplashScreen")]),t._v(" "),v("ul",[v("li",[t._v("通常会将启动画面的代码放在 mian() 函数中，位于 Application::exec() 调用之前")])]),t._v(" "),v("p",[t._v("QTableWidget")]),t._v(" "),v("ul",[v("li",[t._v("与 QTableWidget 不同，QTableWidgetItem 不是一个窗口部件类，而是一个纯粹的数据类")]),t._v(" "),v("li",[t._v("可以在构造函数中使用 setItemPrototype() 用新数据类替换 QTableWidgetItem")])]),t._v(" "),v("p",[t._v("QFile & QDataStream")]),t._v(" "),v("p",[t._v("QApplication::setOverrideCursor(Qt::WaitCursor)\nQApplication::restoreOverrideCursor()")]),t._v(" "),v("p",[t._v("QApplication::clipboard()\nQApplication::beep()")]),t._v(" "),v("p",[t._v("QWidget::update() 和 QWidget::repaint()")]),t._v(" "),v("ul",[v("li",[t._v("QWidget::repaint()\n"),v("ul",[v("li",[t._v("强制产生一个即时的重绘事件")])])]),t._v(" "),v("li",[t._v("QWidget::update():\n"),v("ul",[v("li",[t._v("只是通知 Qt 下一次处理事件时才简单的调用一个绘制事件")]),t._v(" "),v("li",[t._v("如果多次调用 update(), Qt 会把连续多次的绘制事件压缩成一个单一的绘制事件，这样可以避免闪烁现象\n如果窗口部件在屏幕上是不可见的，那么这两个函数会什么都不做")])])])]),t._v(" "),v("p",[t._v("mouseMoveEvent ：当用户按下一个键时才产生，setMouseTracking()")])])}),[],!1,null,null,null);e.default=_.exports}}]);