(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{673:function(t,v,_){"use strict";_.r(v);var e=_(16),d=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"c-features"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#c-features"}},[t._v("#")]),t._v(" C++ features")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("Version")]),t._v(" "),_("th",[t._v("Name")]),t._v(" "),_("th",[t._v("Sample")]),t._v(" "),_("th",[t._v("Note")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("rvalue reference")]),t._v(" "),_("td",[_("code",[t._v("int &&ref_a_left = 6;")])]),t._v(" "),_("td",[t._v("右值引用 和 移动语义")])]),t._v(" "),_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("move semantics")]),t._v(" "),_("td",[_("code",[t._v("std::move")])]),t._v(" "),_("td",[t._v("move and move contructor")])]),t._v(" "),_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("perfect forwarding")]),t._v(" "),_("td",[_("code",[t._v("std::forward")])]),t._v(" "),_("td",[t._v("移动语义 和 完美转发")])]),t._v(" "),_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("decltype")]),t._v(" "),_("td",[_("code",[t._v("int n = 3; decltype(n) t = n + 4;")])]),t._v(" "),_("td",[t._v("类型推导, 以普通表达式作为参数返回该表达式的类型, 注意，decltype 不会对表达式进行求值")])]),t._v(" "),_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("auto")]),t._v(" "),_("td",[_("code",[t._v("auto a = 4 + 6;")])]),t._v(" "),_("td",[t._v("类型推导, 从变量声明的初始化表达式获得变量的类型")])]),t._v(" "),_("tr",[_("td",[t._v("C++14")]),t._v(" "),_("td",[t._v('"auto" return type deduction')]),t._v(" "),_("td",[_("code",[t._v("template <typename A, typename B>")]),_("br"),_("code",[t._v("auto do_something(const A& a, const B& b)")]),_("br"),_("code",[t._v("{ return a.do_something(b); }")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("trailing-return type")]),t._v(" "),_("td",[_("code",[t._v("auto foo(int p) -> int { return p * 42; }")])]),t._v(" "),_("td",[t._v("auto, decltype, trailing-return type")])]),t._v(" "),_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("lambda")]),t._v(" "),_("td",[_("code",[t._v("auto aLambda = [](auto a, auto b) { return a < b; };")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("constexpr")]),t._v(" "),_("td",[_("code",[t._v("constexpr int x = 5;")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("strongly typed enums")]),t._v(" "),_("td",[_("code",[t._v("enum class : char { };")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("static assert")]),t._v(" "),_("td",[_("code",[t._v("static_assert(sizeof(int) == 4);")])]),t._v(" "),_("td",[t._v("编译期的断言")])]),t._v(" "),_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("range based for")]),t._v(" "),_("td",[_("code",[t._v("for (auto x : vec) { /* TODO */ }")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("type alias")]),t._v(" "),_("td",[_("code",[t._v("using func = void (*) (int, int);")])]),t._v(" "),_("td",[t._v("using、typedef、typename"),_("br"),t._v("using 可读性更高，且可以用于模板别名"),_("a",{attrs:{href:"https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889",target:"_blank",rel:"noopener noreferrer"}},[t._v('The "typename" keyword'),_("OutboundLink")],1)])]),t._v(" "),_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("unicode strings")]),t._v(" "),_("td",[_("code",[t._v('const char16_t* utf16 = u"foo";')]),_("br"),_("code",[t._v('const char32_t* utf32 = U"foo";')])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("override")]),t._v(" "),_("td",[_("code",[t._v("struct A { virtual void foo() {}; };")]),_("br"),_("code",[t._v("struct B : public A { void foo() override {}; };")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++17")]),t._v(" "),_("td",[t._v("constexpr if")]),t._v(" "),_("td",[_("code",[t._v("if constexpr (sizeof(int) == 1) return 0;")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++17")]),t._v(" "),_("td",[t._v("template auto")]),t._v(" "),_("td",[_("code",[t._v("template <auto Value>")]),_("br"),_("code",[t._v("struct constant { static constexpr auto value = Value;};")])]),t._v(" "),_("td",[t._v("type and non-type template parameters")])]),t._v(" "),_("tr",[_("td",[t._v("C++17")]),t._v(" "),_("td",[t._v("nested namespace definition")]),t._v(" "),_("td",[_("code",[t._v("namespace A::B::C { class X {}; }")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++17")]),t._v(" "),_("td",[t._v("inline variable")]),t._v(" "),_("td",[_("code",[t._v("class X { static inline int field = 2; };")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++17")]),t._v(" "),_("td",[t._v("structured binding")]),t._v(" "),_("td",[_("code",[t._v("int arr[3] = {3,4,5};")]),_("br"),_("code",[t._v("auto [a, b, c] = arr;")]),_("br"),_("code",[t._v('auto [x, y, z] = std::make_tuple("str", 0.4, 1);')])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++20")]),t._v(" "),_("td",[t._v("designated initializer")]),t._v(" "),_("td",[_("code",[t._v("struct A { int x; int y; int z; };")]),_("br"),_("code",[t._v("A a { .x = 1, .z = 2 };")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++20")]),t._v(" "),_("td",[t._v("modules")]),t._v(" "),_("td",[_("code",[t._v("export module A; import A; import std.core;")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++20")]),t._v(" "),_("td",[t._v("consteval")]),t._v(" "),_("td",[_("code",[t._v("static consteval int square(int n) { return n * n; }")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++20")]),t._v(" "),_("td",[t._v("constinit")]),t._v(" "),_("td",[_("code",[t._v("constinit auto sqrOf5 = square(5);")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++20")]),t._v(" "),_("td",[t._v("concept")]),t._v(" "),_("td",[_("code",[t._v("template<typename T>")]),_("br"),_("code",[t._v("concept Integral = std::is_integral<T>::value;")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++11")]),t._v(" "),_("td",[t._v("attribute specifier sequence")]),t._v(" "),_("td",[_("code",[t._v("[[gnu::const]] [[nodiscard]]")]),_("br"),_("code",[t._v("inline int f();")])]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("C++")]),t._v(" "),_("td",[t._v("enumerators with attributes")]),t._v(" "),_("td",[_("code",[t._v("enum class myEnum{ value1 [[anAttribute]], };")])]),t._v(" "),_("td",[t._v("??")])])])]),t._v(" "),_("h2",{attrs:{id:"一、thriving-in-a-crowded-and-changing-world-c-2006-2020"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、thriving-in-a-crowded-and-changing-world-c-2006-2020"}},[t._v("#")]),t._v(" 一、Thriving in a Crowded and Changing World: C++ 2006–2020")]),t._v(" "),_("p",[t._v("这是 C++ 之父 Bjarne Stroustrup 的 "),_("a",{attrs:{href:"https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("HOPL4"),_("OutboundLink")],1),t._v(" 论文的标题。")]),t._v(" "),_("p",[t._v("HOPL（History of Programming Languages，编程语言历史）ACM（Association of Computing Machines，国际计算机协会）旗下的一个会议，约每十五年举办一次。")]),t._v(" "),_("p",[t._v("Bjarne 的这篇论文是他为 2021 年 HOPL IV 会议准备的论文，它涵盖了 C++98 之后的所有 C++ 版本，从 C++11 直到 C++20。")]),t._v(" "),_("p",[t._v("鉴于这篇论文可以帮助 C++ 从业者对 C++ 的设计原则和历史有一个系统的了解，全球 C++ 及系统软件技术大会的主办方 Boolan 组织了一群译者，把这篇重要论文翻译成了中文: "),_("a",{attrs:{href:"https://github.com/Cpp-Club/Cxx_HOPL4_zh",target:"_blank",rel:"noopener noreferrer"}},[t._v("在拥挤和变化的世界中茁壮成长：C++ 2006–2020"),_("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=d.exports}}]);