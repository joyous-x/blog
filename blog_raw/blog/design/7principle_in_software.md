---
title: 软件设计的7大原则
date: 2020-04-13
description: "软件设计的7大原则"
permalink:
---

# 软件设计的7大原则

#### 开-闭原则(Open-Closed Principle, OCP)
- 对扩展开发,对修改关闭
- 是面向对象设计（OOD）的基石，也是最重要的原则

#### 里氏代换原则(Liskov Substitution Principle)
- 是继承复用的基石
- 严格表达:如果每一个类型为T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有的对象o1都代换称o2时,程序P的行为没有变化,那么类型T2是类型T1的子类型
- 换言之,一个软件实体如果使用的是一个基类的话,那么一定适用于其子类,而且它根本不能察觉出基类对象和子类对象的区别.只有衍生类可以替换基类，软件单位的功能才能不受影响，基类才能真正被复用，而衍生类也能够在基类的基础上增加新功能。
- 反过来的代换不成立
- 该类著名的例程为:正方形是否是长方形的子类(答案是"否")
- 应当尽量从抽象类继承,而不从具体类继承
- my note：描述了继承关系应该满足的条件：子类可以替换父类，并保证程序行为没有变化

#### 依赖倒置原则(Dependence Inversion Principle)
- 抽象不应当依赖于细节,细节应当依赖于抽象.(Program to an interface, not an implementaction)
- 不应当使用具体类进行变量的类型声明,参量类型声明,方法的返还类型声明,以及数据类型的转换等。而应该使用接口和抽象类。

> **==接口与抽象类==**

- 接口与抽象的区别：抽象类可以提供某些方法的部分实现,而接口则不可以,如果向一个抽象类加入一个新的具体方法,那么所有的子类型就都得到得到了这个新的具体方法,而接口做不到这一点.
- 一个抽象类的实现只能由这个抽象类的子类给出,而由于一般语言都限制一个类只能从最多一个超类继承,因此将抽象作为类型定义工具的效能大打折扣.反过来,一个类可以实现任意多个接口.
- 从代码重构的角度,将一个单独的具体类重构成一个接口的实现是很容易的,只需要声明一个接口,并将重要的方法添加到接口声明中,然后在具体类定义语句中加上保留字以继承于该接口就行了.而对具体类重构成一个抽象类的实现，就不那么容易了,因为这个具体类有可能已经有一个超类.这样一来,这个新定义的抽象类只好继续向上移动,变成这个超类的超类,如此循环,最后这个新的抽象类必定处于整个类型等级结构的最上端,从而使登记结构中的所有成员都会受到影响.
- 接口是定义混合类型的理想工具,所为混合类型,就是在一个类的主类型之外的次要类型.一个混合类型表明一个类不仅仅具有某个主类型的行为,而且具有其他的次要行为.
- 联合使用接口和抽象类:
   由于抽象类具有提供缺省实现的优点,而接口具有其他所有优点,所以联合使用两者就是一个很好的选择.
   首先,声明类型的工作仍然接口承担的,但是同时给出的还有一个抽象类,为这个接口给出一个缺省实现.其他同属于这个抽象类型的具体类可以选择实现这个接口,也可以选择继承自这个抽象类.如果一个具体类直接实现这个接口的话,它就必须自行实现所有的接口;相反,如果它继承自抽象类的话,它可以省去一些不必要的的方法,因为它可以从抽象类中自动得到这些方法的缺省实现;如果需要向接口加入一个新的方法的话,那么只要同时向这个抽象类加入这个方法的一个具体实现就可以了,因为所有继承自这个抽象类的子类都会从这个抽象类得到这个具体方法.这其实就是缺省适配器模式(Defaule Adapter).

#### 接口隔离原则(Interface Segregation Principle, ISP)
- 一个类对另外一个类的依赖是建立在最小的接口上
- 使用多个专门的接口比使用单一的总接口要好
- 胖接口会导致他们的客户程序之间产生不正常的耦合.当一个客户程序要求该胖接口进行一个改动时,会影响到所有其他的客户程序.因此客户程序应该仅仅依赖他们实际需要调用的方法.

#### 合成/聚合复用原则(Composite/Aggregate Reuse Principle,CARP)
- 要尽量使用合成/聚合,尽量不要使用继承

#### 迪米特法则(Law of Demeter LoD)
- 又叫做最少知识原则(Least Knowledge Principle,LKP),就是说,一个对象应当对其他对象有尽可能少的了了解

#### 单一职责原则(Simple responsibility pinciple SRP)
- 包括函数 和 类的实现，建议接口一定要单一职责，类的设计尽量做到只有一个原因会引起变化